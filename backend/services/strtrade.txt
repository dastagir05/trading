const cron = require("node-cron");
const AiTrade = require("../models/aiTrade.model");
const StrategyTrade = require("../models/strategyTrade.model");
const fs = require("fs").promises;
const path = require("path");

class StrategyTradeProcessor {
  constructor() {
    this.tradeSuggestionsPath = path.join(
      __dirname,
      "../aiTradeSugg/tradeSuggestions.json"
    );
    this.isProcessing = false;
  }

  init() {
    // convert aitradeS to strategy trades every 30 minutes during market hours
    cron.schedule(
      "16,47 9-14 * * 1-5",
      () => {
        this.processAiTradesToStrategies();
      },
      {
        timezone: "Asia/Kolkata",
      }
    );

    // Monitor suggested strategy trades for activation every 2 minutes
    cron.schedule(
      "*/1 9-15 * * 1-5",
      async () => {
        this.monitorSuggestedStrategyTrades();
      },
      {
        timezone: "Asia/Kolkata",
      }
    );

    // Monitor active strategy trades every 5 minutes
    cron.schedule(
      "*/1 9-15 * * 1-5",
      () => {
        console.log("Monitoring active strategy trades for exit conditions");
        this.monitorActiveStrategyTrades();
      },
      {
        timezone: "Asia/Kolkata",
      }
    );


    console.log("ü§ñ Strategy Trade Processor initialized with cron jobs");
  }

  // Process AI trades that are strategies
  async processAiTradesToStrategies() {
    if (this.isProcessing) {
      console.log("‚è≥ Strategy processing already in progress, skipping...");
      return;
    }

    try {
      this.isProcessing = true;
      console.log("üîÑ Processing AI strategy trades...");

      // Find AI trades marked as strategies that haven't been processed
      const aiTrades = await AiTrade.find({
        isStrategy: true,
        processedToStrategy: { $ne: true },
        isValid: true,
        status: "suggested",
      }).sort({ createdAt: -1 });

      console.log(`Found ${aiTrades.length} AI strategy trades to process`);

      for (const aiTrade of aiTrades) {
        await this.convertAiTradeToStrategy(aiTrade);
      }

      console.log("‚úÖ AI strategy trade processing completed");
    } catch (error) {
      console.error("‚ùå Error processing AI strategy trades:", error);
    } finally {
      this.isProcessing = false;
    }
  }
  parseMultipleValues(valueString) {
    if (!valueString) return [];
    
    // Handle both "&" and "," separators
    const values = valueString.split(/[&,]/).map(val => val.trim());
    return values;
  }
  
  // Convert AI trade to strategy format
  async convertAiTradeToStrategy(aiTrade) {
    try {
      console.log(`Processing strategy: ${aiTrade.title}`);

      // Check if strategy already exists
      const existingStrategy = await StrategyTrade.findOne({
        strategyId: aiTrade.aiTradeId,
      });

      if (existingStrategy) {
        console.log(`Strategy ${aiTrade.aiTradeId} already exists`);
        aiTrade.processedToStrategy = true;
        await aiTrade.save();
        return;
      }

      // Parse individual instruments from strike
      const instruments = this.parseMultiInstrumentStrike(aiTrade.setup.strike);
        // Parse entry, target, and stopLoss values
    const entryValues = this.parseMultipleValues(aiTrade.tradePlan.entry);
    const targetValues = this.parseMultipleValues(aiTrade.tradePlan.target);
    const stopLossValues = this.parseMultipleValues(aiTrade.tradePlan.stopLoss);

    this.validateTradePlanValues(instruments, entryValues, targetValues, stopLossValues);
    console.log(`Found ${instruments.length} instruments`);
    console.log(`Entry values: ${entryValues}`);
    console.log(`Target values: ${targetValues}`);
    console.log(`StopLoss values: ${stopLossValues}`);

      // Create strategy trade
      const strategyTrade = new StrategyTrade({
        strategyId: aiTrade.aiTradeId,
        title: aiTrade.title,
        sentiment: aiTrade.sentiment,
        logic: aiTrade.logic,
        confidence: aiTrade.confidence,
        riskLevel: aiTrade.riskLevel,
        status: "suggested",
        suggestedAt: aiTrade.suggestedAt,
        tags: aiTrade.tags || [],

        // Convert instruments to individual trades
        trades: instruments.map((instrument, index) => ({
          tradeId: `${aiTrade.aiTradeId}_trade_${index + 1}`,
          symbol: this.extractSymbolFromStrike(instrument.strike),
          sentiment: aiTrade.sentiment,

          setup: {
            currentPrice: instrument.currentPrice || aiTrade.setup.currentPrice,
            strategy: aiTrade.setup.strategy,
            strike: instrument.strike,
            expiry: aiTrade.setup.expiry,
          },

          
        tradePlan: {
          entry: entryValues[index] || entryValues[0] || aiTrade.tradePlan.entry,
          target: targetValues[index] || targetValues[0] || aiTrade.tradePlan.target,
          stopLoss: stopLossValues[index] || stopLossValues[0] || aiTrade.tradePlan.stopLoss,
          timeFrame: aiTrade.tradePlan.timeFrame,
        },

          status: "pending",
          isValid: true,
          createdAt: new Date(),
        })),
      });

      await strategyTrade.save();

      // Mark AI trade as processed
      aiTrade.processedToStrategy = true;
      await aiTrade.save();

      console.log(
        `‚úÖ Strategy Trade Seprated: ${aiTrade.title} with ${instruments.length} trades`
      );
    } catch (error) {
      console.error(`‚ùå Error converting AI trade to strategy:`, error);
    }
  }

  // Monitor suggested strategy trades for activation
  async monitorSuggestedStrategyTrades() {
    try {
      const suggestedStrategies = await StrategyTrade.find({
        status: "suggested",
        isValid: true,
      });

      console.log(
        `Found ${suggestedStrategies.length} suggested strategies to monitor`
      );

      for (const strategy of suggestedStrategies) {
        await this.checkStrategyForActivation(strategy);
      }
    } catch (error) {
      console.error("‚ùå Error monitoring suggested strategies:", error);
    }
  }

  // Monitor active strategy trades
  async monitorActiveStrategyTrades() {
    try {
      const activeStrategies = await StrategyTrade.find({
        status: { $in: ["partial_active", "fully_active"] },
        isValid: true,
      });

      console.log(
        `Found ${activeStrategies.length} active strategies to monitor`
      );

      for (const strategy of activeStrategies) {
        await this.checkActiveStrategyStatus(strategy);
      }
    } catch (error) {
      console.error("‚ùå Error monitoring active strategies:", error);
    }
  }

  // Check strategy for activation
  async checkStrategyForActivation(strategy) {
    try {
      const now = new Date();
  
      // Check if any trade in strategy has expired
      const expiredTrades = strategy.trades.filter(
        (trade) => trade.expiryDate && now > trade.expiryDate
      );
  
      if (expiredTrades.length > 0) {
        for (const trade of expiredTrades) {
          await strategy.updateTrade(trade.tradeId, {
            status: "expired",
            exitReason: "Trade expired before activation",
          });
        }
        return;
      }
  
      const pendingTrades = strategy.trades.filter(t => t.status === "pending");
      if (pendingTrades.length === 0) return;
  
      // Get strategy type from first trade
      const strategyType = strategy.trades[0]?.setup?.strategy;
      
      // For straddle/strangle strategies, activate all legs together
      if (strategyType === "Straddle" || strategyType === "Strangle") {
        console.log(`Checking ${strategyType} strategy for simultaneous activation`);
        
        const allTradesReady = await this.checkAllTradesReady(pendingTrades);
        if (allTradesReady) {
          console.log(`All ${strategyType} trades ready, activating together`);
          // Activate all trades together
          for (const trade of pendingTrades) {
            await this.activateStrategyTrade(strategy, trade);
          }
        } else {
          console.log(`${strategyType} strategy not ready - waiting for all legs`);
        }
      } else {
        // For other strategies (like Bear Put Spread), check individual trades
        console.log(`Checking individual trades for ${strategyType || 'multi-leg'} strategy`);
        
        for (const trade of pendingTrades) {
          const shouldActivate = await this.checkTradeEntryConditions(trade);
          if (shouldActivate) {
            await this.activateStrategyTrade(strategy, trade);
          }
        }
      }
    } catch (error) {
      console.error(`‚ùå Error checking strategy for activation:`, error);
    }
  }
  
  async checkAllTradesReady(trades) {
    let readyCount = 0;
    
    for (const trade of trades) {
      const ready = await this.checkTradeEntryConditions(trade);
      if (ready) {
        readyCount++;
      }
      console.log(`Trade ${trade.setup.strike}: Ready = ${ready}`);
    }
    
    console.log(`${readyCount}/${trades.length} trades ready for activation`);
    return readyCount === trades.length;
  }
  
  // Fixed entry conditions with more reasonable tolerance
  async checkTradeEntryConditions(trade) {
    try {
      const words = trade.setup.strike.split(" ");
      const currentPrice = await this.getCurrentMarketPrice(words);
      const suggestedEntry = this.parsePrice(trade.tradePlan.entry);
  
      if (!currentPrice || !suggestedEntry) {
        console.log(`Cannot get price data for ${trade.setup.strike}`);
        return false;
      }
  
      // Use more reasonable tolerance - 10% for options
      const tolerancePercent = 0.10; // 10%
      const tolerance = suggestedEntry * tolerancePercent;
      const priceDiff = Math.abs(currentPrice - suggestedEntry);
      const priceInRange = priceDiff <= tolerance;
  
      console.log(
        `Entry check for ${trade.setup.strike}:
        Current: ‚Çπ${currentPrice}
        Suggested: ‚Çπ${suggestedEntry} 
        Difference: ‚Çπ${priceDiff.toFixed(2)}
        Tolerance: ‚Çπ${tolerance.toFixed(2)} (${tolerancePercent * 100}%)
        In Range: ${priceInRange}`
      );
  
      return priceInRange;
    } catch (error) {
      console.error(`‚ùå Error checking trade entry conditions:`, error);
      return false;
    }
  }

  // Activate individual trade within strategy
  async activateStrategyTrade(strategy, trade) {
    try {
      const words = trade.setup.strike.split(" ");
      const currentPrice = await this.getCurrentMarketPrice(words);

      await strategy.updateTrade(trade.tradeId, {
        status: "active",
        entryPrice: currentPrice,
        entryTime: new Date(),
        quantity: words[0] === "Nifty" ? 75 : 35,
      });

      await strategy.addNote(
        `Trade ${trade.tradeId} activated at ‚Çπ${currentPrice}`,
        "success"
      );

      console.log(
        `üöÄ Strategy trade activated: ${trade.setup.strike} at ‚Çπ${currentPrice}`
      );
    } catch (error) {
      console.error(`‚ùå Error activating strategy trade:`, error);
    }
  }

  // Check active strategy status
  async checkActiveStrategyStatus(strategy) {
    try {
      const now = new Date();

      for (const trade of strategy.trades.filter(
        (t) => t.status === "active"
      )) {
        // Check if trade has expired
        if (trade.expiryDate && now > trade.expiryDate) {
          await this.handleExpiredTrade(strategy, trade);
          continue;
        }

        // Check target/stop loss
        await this.checkTradeTargetStopLoss(strategy, trade);
      }
    } catch (error) {
      console.error(`‚ùå Error checking active strategy status:`, error);
    }
  }

  // Handle expired trade
  async handleExpiredTrade(strategy, trade) {
    try {
      const words = trade.setup.strike.split(" ");
      const currentPrice = await this.getCurrentMarketPrice(words);

      await strategy.updateTrade(trade.tradeId, {
        status: "expired",
        exitPrice: currentPrice,
        exitTime: new Date(),
        exitReason: "Trade expired based on timeframe",
      });

      this.calculateTradeCharges(currentPrice, trade);

      await strategy.addNote(
        `Trade ${trade.tradeId} expired at ‚Çπ${currentPrice}`,
        "warning"
      );
    } catch (error) {
      console.error(`‚ùå Error handling expired trade:`, error);
    }
  }

  // Check target and stop loss for individual trade
  async checkTradeTargetStopLoss(strategy, trade) {
    try {
      const words = trade.setup.strike.split(" ");
      const currentPrice = await this.getCurrentMarketPrice(words);
      const targetPrice = this.parsePrice(trade.tradePlan.target);
      const stopLossPrice = this.parsePrice(trade.tradePlan.stopLoss);

      if (!currentPrice || !targetPrice || !stopLossPrice) {
        console.log(`Missing price data for ${trade.setup.strike}`);
        return;
      }

      // Check for target hit
      if (currentPrice >= targetPrice) {
        await this.handleTargetHit(strategy, trade, currentPrice);
      }
      // Check for stop loss hit
      else if (currentPrice <= stopLossPrice) {
        await this.handleStopLossHit(strategy, trade, currentPrice);
      }
    } catch (error) {
      console.error(`‚ùå Error checking trade target/stop loss:`, error);
    }
  }

  // Handle target hit
  async handleTargetHit(strategy, trade, currentPrice) {
    const pnl = this.calculatePnL(trade.entryPrice, currentPrice);

    await strategy.updateTrade(trade.tradeId, {
      status: "target_hit",
      exitPrice: currentPrice,
      exitTime: new Date(),
      exitReason: "Target price achieved",
      pnl: pnl * trade.quantity,
    });

    this.calculateTradeCharges(currentPrice, trade);

    await strategy.addNote(
      `Trade ${trade.tradeId} target hit at ‚Çπ${currentPrice}. P&L: ‚Çπ${pnl}`,
      "success"
    );
  }

  // Handle stop loss hit
  async handleStopLossHit(strategy, trade, currentPrice) {
    const pnl = this.calculatePnL(trade.entryPrice, currentPrice);

    await strategy.updateTrade(trade.tradeId, {
      status: "stoploss_hit",
      exitPrice: currentPrice,
      exitTime: new Date(),
      exitReason: "Stop loss triggered",
      pnl: pnl * trade.quantity,
    });

    this.calculateTradeCharges(currentPrice, trade);

    await strategy.addNote(
      `Trade ${
        trade.tradeId
      } stop loss hit at ‚Çπ${currentPrice}. P&L: ‚Çπ${pnl.toFixed(2)}`,
      "warning"
    );
  }

  // Calculate trade charges
  calculateTradeCharges(last_price, trade) {
    const brokerage = 40;
    const stt = last_price * trade.quantity * 0.001;
    const sebi = trade.entryPrice * last_price * trade.quantity * 0.000001;
    const gst = brokerage * 0.18;
    const totalCharges = parseFloat((brokerage + stt + sebi + gst).toFixed(2));

    const grossPnl = trade.pnl;
    const netPnl = grossPnl - totalCharges;
    const percentPnL = parseFloat(
      ((grossPnl / (trade.entryPrice * trade.quantity)) * 100).toFixed(2)
    );

    trade.netPnL = parseFloat(netPnl.toFixed(2));
    trade.percentPnL = percentPnL;
    trade.charges = {
      brokerage: +brokerage.toFixed(2),
      stt: +stt.toFixed(2),
      sebi: +sebi.toFixed(2),
      gst: +gst.toFixed(2),
      total: totalCharges,
    };
  }

  // Daily cleanup for strategies
  async dailyStrategyCleanup() {
    try {
      console.log("üßπ Starting daily strategy cleanup...");

      // Mark expired strategies
      const expiredStrategies = await StrategyTrade.find({
        status: "suggested",
        isValid: true,
      });

      for (const strategy of expiredStrategies) {
        const now = new Date();
        const expiredTrades = strategy.trades.filter(
          (trade) => trade.expiryDate && now > trade.expiryDate
        );

        if (expiredTrades.length > 0) {
          for (const trade of expiredTrades) {
            await strategy.updateTrade(trade.tradeId, {
              status: "expired",
              exitReason: "Trade expired during cleanup",
            });
          }
        }
      }

      console.log("‚úÖ Daily strategy cleanup completed");
    } catch (error) {
      console.error("‚ùå Error during daily strategy cleanup:", error);
    }
  }

  // Helper methods (same as your AiTradeProcessor)
  parseMultiInstrumentStrike(strikeString) {
    if (!strikeString.includes(" & ")) {
      return [{ strike: strikeString.trim() }];
    }
  
    const instruments = strikeString.split(" & ");
    return instruments.map((instrument) => ({
      strike: instrument.trim(),
      currentPrice: this.extractCurrentPriceFromStrike(instrument.trim()),
    }));
  }

  extractSymbolFromStrike(strike) {
    if (!strike) return "Unknown";
    const parts = strike.split(" ");
    return parts[0];
  }

  generateInstrumentKey(strike) {
    const parts = strike.split(" ");
    if (parts.length >= 3) {
      const symbol = parts[0];
      const strikePrice = parts[1];
      const optionType = parts[2];
      return `${symbol.toUpperCase()}${strikePrice}${
        optionType === "CALL" ? "CE" : "PE"
      }`;
    }
    return strike;
  }

  extractCurrentPriceFromStrike(strike) {
    return null;
  }

  parsePrice(priceString) {
    if (!priceString) return null;
    const cleanPrice = priceString.toString().replace(/[‚Çπ,\s]/g, "");
    const price = parseFloat(cleanPrice);
    return isNaN(price) ? null : price;
  }

  validateTradePlanValues(instruments, entryValues, targetValues, stopLossValues) {
    const instrumentCount = instruments.length;
    
    if (entryValues.length !== instrumentCount) {
      console.warn(`‚ö†Ô∏è Entry values count (${entryValues.length}) doesn't match instruments count (${instrumentCount})`);
    }
    
    if (targetValues.length !== instrumentCount) {
      console.warn(`‚ö†Ô∏è Target values count (${targetValues.length}) doesn't match instruments count (${instrumentCount})`);
    }
    
    if (stopLossValues.length !== instrumentCount) {
      console.warn(`‚ö†Ô∏è StopLoss values count (${stopLossValues.length}) doesn't match instruments count (${instrumentCount})`);
    }
  }

  calculatePnL(entryPrice, exitPrice) {
    return exitPrice - entryPrice;
  }

  async getCurrentMarketPrice(words) {
    const [name, strikePrice, side] = words;
    const filePath = path.join(
      __dirname,
      "../aiTradeSugg/setOptionData/marketData.json"
    );

    try {
      const rawData = await fs.readFile(filePath, "utf8");
      const marketData = JSON.parse(rawData);

      if (name === "Nifty") {
        const activeOP = marketData.nifty.optionChain;
        for (const stpr of activeOP) {
          if (stpr.strike_price == strikePrice) {
            return side === "CALL" ? stpr.call?.ltp : stpr.put?.ltp;
          }
        }
      } else {
        const activeOP = marketData.bankNifty.optionChain;
        for (const stpr of activeOP) {
          if (stpr.strike_price == strikePrice) {
            return side === "CALL" ? stpr.call?.ltp : stpr.put?.ltp;
          }
        }
      }

      // Fallback to random price if not found
      const basePrice = 100;
      const randomVariation = (Math.random() - 0.5) * 10;
      return basePrice + randomVariation;
    } catch (error) {
      console.error(`Error getting current price for ${strikePrice}:`, error);
      return null;
    }
  }
}

module.exports = new StrategyTradeProcessor();
