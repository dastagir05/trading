const cron = require('node-cron');
const AiTrade = require('../models/aiTrade.model');
const fs = require('fs').promises;
const path = require('path');

class AiTradeProcessor {
  constructor() {
    this.tradeSuggestionsPath = path.join(__dirname, '../aiTradeSugg/tradeSuggestions.json');
    this.isProcessing = false;
  }

  // Initialize the cron jobs
  init() {
    // Generate fresh trade suggestions every 30 minutes during market hours
    cron.schedule('*/30 9-15 * * 1-5', () => {
      this.generateFreshSuggestions();
    }, {
      timezone: "Asia/Kolkata"
    });

    // Monitor active AI trades every 5 minutes during market hours
    cron.schedule('*/5 9-15 * * 1-5', () => {
      console.log("i am active moniteringacttrad")
      this.monitorActiveTrades();
    }, {
      timezone: "Asia/Kolkata"
    });

    // Daily cleanup and reporting at 6 PM
    cron.schedule('0 18 * * 1-5', () => {
      this.dailyCleanup();
    }, {
      timezone: "Asia/Kolkata"
    });

    console.log('ü§ñ AI Trade Processor initialized with cron jobs');
  }

  // Generate fresh trade suggestions
  async generateFreshSuggestions() {
    if (this.isProcessing) {
      console.log('‚è≥ Fresh trade generation already in progress, skipping...');
      return;
    }

    try {
      this.isProcessing = true;
      console.log('üîÑ Generating fresh AI trade suggestions...');

      // Import the fresh trade generator
      const { generateFreshTradeSuggestions } = require('../aiTradeSugg/generateFreshTrades');
      
      // Generate fresh suggestions
      const freshTrades = await generateFreshTradeSuggestions();
      
      console.log(`‚úÖ Generated ${freshTrades.length} fresh trade suggestions`);
    } catch (error) {
      console.error('‚ùå Error generating fresh trade suggestions:', error);
    } finally {
      this.isProcessing = false;
    }
  }

  // Process new trade suggestions from JSON file (legacy method)
  async processNewSuggestions() {
    if (this.isProcessing) {
      console.log('‚è≥ AI Trade processing already in progress, skipping...');
      return;
    }

    try {
      this.isProcessing = true;
      console.log('üîÑ Processing new AI trade suggestions...');

      const suggestionsData = await fs.readFile(this.tradeSuggestionsPath, 'utf8');
      const suggestions = JSON.parse(suggestionsData);

      for (const suggestion of suggestions) {
        await this.processSuggestion(suggestion);
      }

      console.log('‚úÖ AI trade suggestions processed successfully');
    } catch (error) {
      console.error('‚ùå Error processing AI trade suggestions:', error);
    } finally {
      this.isProcessing = false;
    }
  }

  // Process individual trade suggestion
  async processSuggestion(suggestion) {
    try {
      // Check if this suggestion already exists
      const existingTrade = await AiTrade.findOne({ aiTradeId: suggestion.id });
      
      if (existingTrade) {
        // Update existing trade if needed
        if (existingTrade.status === 'suggested') {
          await this.updateSuggestion(existingTrade, suggestion);
        }
        return;
      }

      // Create new AI trade
      const aiTrade = new AiTrade({
        aiTradeId: suggestion.id,
        title: suggestion.title,
        sentiment: suggestion.sentiment,
        setup: {
          currentPrice: suggestion.setup.currentPrice,
          strategy: suggestion.setup.strategy,
          strike: suggestion.setup.strike,
          expiry: suggestion.setup.expiry,
          symbol: this.extractSymbol(suggestion.setup.strike),
        },
        tradePlan: suggestion.tradePlan,
        logic: suggestion.logic,
        confidence: suggestion.confidence,
        riskLevel: suggestion.riskLevel,
        suggestedAt: new Date(suggestion.timestamp),
        tags: this.generateTags(suggestion),
      });

      await aiTrade.save();
      console.log(`üìù New AI trade created: ${suggestion.title}`);
      
      // Add initial note
      await aiTrade.addNote('AI trade suggestion created', 'info');
      
    } catch (error) {
      console.error(`‚ùå Error processing suggestion ${suggestion.id}:`, error);
    }
  }

  // Update existing suggestion
  async updateSuggestion(existingTrade, suggestion) {
    try {
      // Update relevant fields
      existingTrade.setup.currentPrice = suggestion.setup.currentPrice;
      existingTrade.confidence = suggestion.confidence;
      existingTrade.riskLevel = suggestion.riskLevel;
      existingTrade.tradePlan = suggestion.tradePlan;
      
      await existingTrade.save();
      await existingTrade.addNote('Trade suggestion updated', 'info');
      
      console.log(`üîÑ Updated AI trade: ${suggestion.title}`);
    } catch (error) {
      console.error(`‚ùå Error updating suggestion ${suggestion.id}:`, error);
    }
  }

  // Monitor active AI trades
  async monitorActiveTrades() {
    try {
      const activeTrades = await AiTrade.find({ 
        status: 'active',
        isValid: true 
      });

      for (const trade of activeTrades) {
        await this.checkTradeStatus(trade);
      }
    } catch (error) {
      console.error('‚ùå Error monitoring active trades:', error);
    }
  }

  // Check individual trade status
  async checkTradeStatus(trade) {
    try {
      const now = new Date();
      
      // Check if trade has expired
      if (trade.expiryDate && now > trade.expiryDate) {
        await trade.updateStatus('expired', 'Trade expired based on timeframe');
        await trade.addNote(`Trade expired at ${trade.expiryDate}`, 'warning');
        console.log(`‚è∞ AI trade expired: ${trade.title}`);
        return;
      }
      console.log("chTra", trade.status)

      // Check if it's time to activate the trade (market open)
      if (trade.status === 'suggested' && this.isMarketOpen()) {
        await this.activateTrade(trade);
      }

      // For active trades, check target and stop loss (this would integrate with market data)
      if (trade.status === 'active') {
        await this.checkTargetStopLoss(trade);
      }

    } catch (error) {
      console.error(`‚ùå Error checking trade status for ${trade.aiTradeId}:`, error);
    }
  }

  // Activate a trade
  async activateTrade(trade) {
    try {
      // Here you would integrate with your market data service
      // For now, we'll simulate activation
      await trade.updateStatus('active');
      await trade.addNote('Trade activated - monitoring for entry conditions', 'success');
      
      console.log(`üöÄ AI trade activated: ${trade.title}`);
    } catch (error) {
      console.error(`‚ùå Error activating trade ${trade.aiTradeId}:`, error);
    }
  }

  // Check target and stop loss (placeholder for market data integration)
  async checkTargetStopLoss(trade) {
    try {
      // This is where you'd integrate with your market data service
      // For now, it's a placeholder
      // const currentPrice = await getCurrentPrice(trade.setup.symbol);
      // const entryPrice = parseFloat(trade.tradePlan.entry.replace('‚Çπ', ''));
      // const targetPrice = parseFloat(trade.tradePlan.target.replace('‚Çπ', ''));
      // const stopLossPrice = parseFloat(trade.tradePlan.stopLoss.replace('‚Çπ', ''));
      
      // if (currentPrice >= targetPrice) {
      //   await trade.updateStatus('target_hit', 'Target price achieved');
      //   await trade.addNote(`Target hit at ‚Çπ${currentPrice}`, 'success');
      // } else if (currentPrice <= stopLossPrice) {
      //   await trade.updateStatus('stoploss_hit', 'Stop loss triggered');
      //   await trade.addNote(`Stop loss hit at ‚Çπ${currentPrice}`, 'warning');
      // }
      
    } catch (error) {
      console.error(`‚ùå Error checking target/stop loss for ${trade.aiTradeId}:`, error);
    }
  }

  // Daily cleanup and reporting
  async dailyCleanup() {
    try {
      console.log('üßπ Starting daily AI trade cleanup...');
      
      // Mark expired suggestions as invalid
      const expiredSuggestions = await AiTrade.find({
        status: 'suggested',
        expiryDate: { $lt: new Date() },
        isValid: true
      });

      for (const trade of expiredSuggestions) {
        trade.isValid = false;
        await trade.save();
        await trade.addNote('Trade suggestion expired and marked as invalid', 'warning');
      }

      // Generate daily report
      await this.generateDailyReport();
      
      console.log('‚úÖ Daily cleanup completed');
    } catch (error) {
      console.error('‚ùå Error during daily cleanup:', error);
    }
  }

  // Generate daily report
  async generateDailyReport() {
    try {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);

      const dailyStats = await AiTrade.aggregate([
        {
          $match: {
            createdAt: { $gte: today, $lt: tomorrow }
          }
        },
        {
          $group: {
            _id: '$status',
            count: { $sum: 1 },
            totalConfidence: { $avg: '$confidence' }
          }
        }
      ]);

      const totalTrades = await AiTrade.countDocuments({
        createdAt: { $gte: today, $lt: tomorrow }
      });

      console.log('üìä Daily AI Trade Report:');
      console.log(`Total suggestions: ${totalTrades}`);
      dailyStats.forEach(stat => {
        console.log(`${stat._id}: ${stat.count} trades, Avg confidence: ${stat.totalConfidence?.toFixed(1) || 'N/A'}%`);
      });

    } catch (error) {
      console.error('‚ùå Error generating daily report:', error);
    }
  }

  // Helper methods
  extractSymbol(strike) {
    if (!strike) return 'Unknown';
    if (strike.includes('CE') || strike.includes('PE')) {
      return strike.split(' ')[0]; // Extract symbol from "NIFTY 24650 CE"
    }
    return strike;
  }

  generateTags(suggestion) {
    const tags = [];
    
    if (suggestion.setup.strategy) tags.push(suggestion.setup.strategy);
    if (suggestion.sentiment) tags.push(suggestion.sentiment);
    if (suggestion.riskLevel) tags.push(suggestion.riskLevel);
    if (suggestion.tradePlan.timeFrame) tags.push(suggestion.tradePlan.timeFrame);
    
    return tags;
  }

  isMarketOpen() {
    const now = new Date();
    const hour = now.getHours();
    const minute = now.getMinutes();
    const currentTime = hour * 100 + minute;
    
    // Market hours: 9:15 AM to 3:30 PM (IST)
    return currentTime >= 915 && currentTime <= 1530;
  }

  // Get AI trade statistics
  async getStats() {
    try {
      const stats = await AiTrade.aggregate([
        {
          $group: {
            _id: null,
            totalTrades: { $sum: 1 },
            activeTrades: { $sum: { $cond: [{ $eq: ['$status', 'active'] }, 1, 0] } },
            completedTrades: { $sum: { $cond: [{ $in: ['$status', ['target_hit', 'stoploss_hit', 'expired']] }, 1, 0] } },
            avgConfidence: { $avg: '$confidence' },
            totalPnL: { $sum: { $ifNull: ['$pnl', 0] } },
            winRate: {
              $avg: {
                $cond: [
                  { $and: [{ $ne: ['$status', 'suggested'] }, { $ne: ['$status', 'active'] }] },
                  { $cond: [{ $gt: ['$pnl', 0] }, 1, 0] },
                  null
                ]
              }
            }
          }
        }
      ]);

      return stats[0] || {};
    } catch (error) {
      console.error('‚ùå Error getting AI trade stats:', error);
      return {};
    }
  }

  // Get AI trades by status
  async getTradesByStatus(status, limit = 50) {
    try {
      const query = status === 'all' ? {} : { status };
      return await AiTrade.find(query)
        .sort({ createdAt: -1 })
        .limit(limit);
    } catch (error) {
      console.error(`‚ùå Error getting trades by status ${status}:`, error);
      return [];
    }
  }
}

module.exports = new AiTradeProcessor();
